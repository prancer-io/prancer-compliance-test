{
    "testSet": [
        {
            "masterTestName": "Kubernetes_cloud_TEST",
            "version": "0.1",
            "cases": [
                {
                    "masterTestId": "K8S_test_0001",
                    "masterSnapshotId": [
                        "K8SSNP_CLUSTERROLE_",
                        "K8SSNP_ROLE_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0001.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0001",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Where possible, remove get, list and watch access to secret objects in the cluster.",
                            "remediationFunction": "PR-K8S-0001.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": "MINIMIZE ACCESS TO SECRETS (RBAC)",
                    "description": "The Kubernetes API stores secrets, which may be service account tokens for the Kubernetes API or credentials used by workloads in the cluster. Access to these secrets should be restricted to the smallest possible group of users to reduce the risk of privilege escalation. Inappropriate access to secrets stored within the Kubernetes cluster can allow for an attacker to gain additional access to the Kubernetes cluster or external resources whose credentials are stored as secrets.",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "clusterrole",
                                "role"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0002",
                    "masterSnapshotId": [
                        "K8SSNP_CLUSTERROLE_",
                        "K8SSNP_ROLE_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0002.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0002",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Where possible, remove get, list and watch access to secret objects in the cluster.",
                            "remediationFunction": "PR-K8S-0002.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": "Minimize wildcard use in Roles and ClusterRoles (RBAC)",
                    "description": "Kubernetes Roles and ClusterRoles provide access to resources based on sets of objects and actions that can be taken on those objects. It is possible to set either of these to be the wildcard \" * \" which matches all items. Use of wildcards is not optimal from a security perspective as it may allow for inadvertent access to be granted when new resources are added to the Kubernetes API either as CRDs or in later versions of the product. The principle of least privilege recommends that users are provided only the access required for their role and nothing more. The use of wildcard rights grants is likely to provide excessive rights to the Kubernetes API.",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "clusterrole",
                                "role"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0003",
                    "masterSnapshotId": [
                        "K8SSNP_ROLEBINDING_",
                        "K8SSNP_CLUSTERROLEBINDING_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0003.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0003",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Create explicit service accounts wherever a Kubernetes workload requires specific access to the Kubernetes API server. Modify the configuration of each default service account to include this value: automountServiceAccountToken: false",
                            "remediationFunction": "PR-K8S-0003.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": "Ensure that default service accounts are not actively used. (RBAC)",
                    "description": "The default service account should not be used to ensure that rights granted to applications can be more easily audited and reviewed. Kubernetes provides a default service account which is used by cluster workloads where no specific service account is assigned to the pod. Where access to the Kubernetes API from a pod is required, a specific service account should be created for that pod, and rights granted to that service account. The default service account should be configured such that it does not provide a service account token and does not have any explicit rights assignments.",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "rolebinding",
                                "clusterrolebinding"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0004",
                    "masterSnapshotId": [
                        "K8SSNP_ROLEBINDING_",
                        "K8SSNP_CLUSTERROLEBINDING_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0004.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0004",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Identify all clusterrolebindings to the cluster-admin role. Check if they are used and if they need this role or if they could use a role with fewer privileges. Where possible, first bind users to a lower privileged role and then remove the clusterrolebinding to the cluster-admin role : kubectl delete clusterrolebinding [name] ",
                            "remediationFunction": "PR-K8S-0004.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": "Ensure that the cluster-admin role is only used where required (RBAC)",
                    "description": "The RBAC role cluster-admin provides wide-ranging powers over the environment and should be used only where and when needed. Kubernetes provides a set of default roles where RBAC is used. Some of these roles such as cluster-admin provide wide-ranging privileges which should only be applied where absolutely necessary. Roles such as cluster-admin allow super-user access to perform any action on any resource. When used in a ClusterRoleBinding, it gives full control over every resource in the cluster and in all namespaces. When used in a RoleBinding, it gives full control over every resource in the rolebinding's namespace, including the namespace itself.",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "rolebinding",
                                "clusterrolebinding"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0008",
                    "masterSnapshotId": [
                        "K8SSNP_PODSECURITYPOLICY_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0008.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0008",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Create a PSP as described in the Kubernetes documentation, ensuring that the .spec.privileged field is omitted or set to false.  References: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#enabling-pod-security-policies",
                            "remediationFunction": "PR-K8S-0008.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": "Minimize the admission of privileged containers (PSP)",
                    "description": "Do not generally permit containers to be run with the securityContext.privileged flag set to true. Privileged containers have access to all Linux Kernel capabilities and devices. A container running with full privileges can do almost everything that the host can do. This flag exists to allow special use-cases, like manipulating the network stack and accessing devices. There should be at least one PodSecurityPolicy (PSP) defined which does not permit privileged containers. If you need to run privileged containers, this should be defined in a separate PSP and you should carefully check RBAC controls to ensure that only limited service accounts and users are given permission to access that PSP. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "podsecuritypolicy"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0009",
                    "masterSnapshotId": [
                        "K8SSNP_PODSECURITYPOLICY_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0009.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0009",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Create a PSP as described in the Kubernetes documentation, ensuring that the .spec.runAsUser.rule is set to either MustRunAsNonRoot or MustRunAs with the range of UIDs not including 0. References: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#enabling-pod-security-policies",
                            "remediationFunction": "PR-K8S-0009.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": "Minimize the admission of root containers (PSP)",
                    "description": "Do not generally permit containers to be run as the root user. Containers may run as any Linux user. Containers which run as the root user, whilst constrained by Container Runtime security features still have a escalated likelihood of container breakout. Ideally, all containers should run as a defined non-UID 0 user. There should be at least one PodSecurityPolicy (PSP) defined which does not permit root users in a container. If you need to run root containers, this should be defined in a separate PSP and you should carefully check RBAC controls to ensure that only limited service accounts and users are given permission to access that PSP.",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "podsecuritypolicy"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0010",
                    "masterSnapshotId": [
                        "K8SSNP_PODSECURITYPOLICY_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0010.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0010",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Create a PSP as described in the Kubernetes documentation, ensuring that the .spec.requiredDropCapabilities is set to include either NET_RAW or ALL. References: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#enabling-pod-security-policies https://www.nccgroup.trust/uk/our-research/abusing-privileged-and-unprivileged-linux-containers/",
                            "remediationFunction": "PR-K8S-0010.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": "Minimize the admission of containers with the NET_RAW capability (PSP)",
                    "description": "Do not generally permit containers with the potentially dangerous NET_RAW capability. Containers run with a default set of capabilities as assigned by the Container Runtime. By default this can include potentially dangerous capabilities. With Docker as the container runtime the NET_RAW capability is enabled which may be misused by malicious containers. Ideally, all containers should drop this capability. There should be at least one PodSecurityPolicy (PSP) defined which prevents containers with the NET_RAW capability from launching. If you need to run containers with this capability, this should be defined in a separate PSP and you should carefully check RBAC controls to ensure that only limited service accounts and users are given permission to access that PSP. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "podsecuritypolicy"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0011",
                    "masterSnapshotId": [
                        "K8SSNP_PODSECURITYPOLICY_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0011.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0011",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Create a PSP as described in the Kubernetes documentation, ensuring that the .spec.hostIPC field is omitted or set to false. References: https://kubernetes.io/docs/concepts/policy/pod-security-policy",
                            "remediationFunction": "PR-K8S-0011.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": "Minimize the admission of containers wishing to share the host IPC namespace (PSP)",
                    "description": " Do not generally permit containers to be run with the hostIPC flag set to true. A container running in the host's IPC namespace can use IPC to interact with processes outside the container. There should be at least one PodSecurityPolicy (PSP) defined which does not permit containers to share the host IPC namespace. If you have a requirement to containers which require hostIPC, this should be defined in a separate PSP and you should carefully check RBAC controls to ensure that only limited service accounts and users are given permission to access that PSP.",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "podsecuritypolicy"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0012",
                    "masterSnapshotId": [
                        "K8SSNP_PODSECURITYPOLICY_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0012.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0012",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Create a PSP as described in the Kubernetes documentation, ensuring that the .spec.hostNetwork field is omitted or set to false. References: https://kubernetes.io/docs/concepts/policy/pod-security-policy",
                            "remediationFunction": "PR-K8S-0012.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": "Minimize the admission of containers wishing to share the host network namespace (PSP)",
                    "description": " Do not generally permit containers to be run with the hostNetwork flag set to true. A container running in the host's network namespace could access the local loopback device, and could access network traffic to and from other pods. There should be at least one PodSecurityPolicy (PSP) defined which does not permit containers to share the host network namespace. If you have need to run containers which require hostNetwork, this should be defined in a separate PSP and you should carefully check RBAC controls to ensure that only limited service accounts and users are given permission to access that PSP.",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "podsecuritypolicy"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0013",
                    "masterSnapshotId": [
                        "K8SSNP_PODSECURITYPOLICY_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0013.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0013",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Create a PSP as described in the Kubernetes documentation, ensuring that the .spec.hostPID field is omitted or set to false. References: https://kubernetes.io/docs/concepts/policy/pod-security-policy",
                            "remediationFunction": "PR-K8S-0013.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": "Minimize the admission of containers wishing to share the host process ID namespace (PSP)",
                    "description": " Do not generally permit containers to be run with the hostPID flag set to true. A container running in the host's PID namespace can inspect processes running outside the container. If the container also has access to ptrace capabilities this can be used to escalate privileges outside of the container. There should be at least one PodSecurityPolicy (PSP) defined which does not permit containers to share the host PID namespace. If you need to run containers which require hostPID, this should be defined in a separate PSP and you should carefully check RBAC controls to ensure that only limited service accounts and users are given permission to access that PSP.",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "podsecuritypolicy"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0014",
                    "masterSnapshotId": [
                        "K8SSNP_PODSECURITYPOLICY_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0014.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0014",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Create a PSP as described in the Kubernetes documentation, ensuring that the .spec.allowPrivilegeEscalation field is omitted or set to false. References: https://kubernetes.io/docs/concepts/policy/pod-security-policy",
                            "remediationFunction": "PR-K8S-0014.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": "Minimize the admission of containers with allowPrivilegeEscalation (PSP)",
                    "description": "Do not generally permit containers to be run with the allowPrivilegeEscalation flag set to true.",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "podsecuritypolicy"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0015",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0015.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0015",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": " Create a PSP as described in the Kubernetes documentation, ensuring that the .spec.runAsUser.rule is set to either MustRunAsNonRoot or MustRunAs with the range of UIDs not including 0.",
                            "remediationFunction": "PR-K8S-0015.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": "Do not admit root containers",
                    "description": "Do not generally permit containers to be run as the root user.",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0016",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0016.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0016",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the etcd pod specification file $etcdconf on the master node and set the below parameter. --peer-client-cert-auth=true References: https://coreos.com/etcd/docs/latest/op-guide/security.html https://kubernetes.io/docs/admin/etcd/ https://coreos.com/etcd/docs/latest/op-guide/configuration.html#peer-client-cert-auth",
                            "remediationFunction": "PR-K8S-0016.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": "Ensure that the --peer-client-cert-auth argument is set to true (etcd)",
                    "description": " etcd should be configured for peer authentication. etcd is a highly-available key value store used by Kubernetes deployments for persistent storage of all of its REST API objects. These objects are sensitive in nature and should be accessible only by authenticated etcd peers in the etcd cluster.",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0017",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0017.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0017",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the etcd pod specification file $etcdconf on the master /n node and either remove the --peer-auto-tls parameter or set it to false. --peer-auto-tls=false References: https://coreos.com/etcd/docs/latest/op-guide/security.html https://kubernetes.io/docs/admin/etcd/ https://coreos.com/etcd/docs/latest/op-guide/configuration.html#peer-auto-tls",
                            "remediationFunction": "PR-K8S-0017.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": "Ensure that the --peer-auto-tls argument is not set to true (etcd)",
                    "description": " Do not use automatically generated self-signed certificates for TLS connections between peers. etcd is a highly-available key value store used by Kubernetes deployments for persistent storage of all of its REST API objects. These objects are sensitive in nature and should be accessible only by authenticated etcd peers in the etcd cluster. Hence, do not use self-signed certificates for authentication. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0018",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0018.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0018",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Use this example PodSecurityPolicy object in a file to create a policy that simply prevents the creation of privileged pods. apiVersion: policy/v1beta1 /n kind: PodSecurityPolicy /n metadata: /n name: example /n spec: /n privileged: false # Don't allow privileged pods! /n # The rest fills in some required fields. seLinux: /n rule: RunAsAny /n supplementalGroups: /n rule: RunAsAny /n runAsUser: /n rule: RunAsAny /n fsGroup: /n rule: RunAsAny /n volumes: /n - '*' /n For more on how to enable and update pod specification using Pod Security Policy, please refer : https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privileged",
                            "remediationFunction": "PR-K8S-0018.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": "Ensure that Containers are not running in privileged mode",
                    "description": " Pod Security Policies are cluster-wide resources that control security sensitive aspects of pod specification. Pod Security Policy objects define a set of conditions that a pod must run with in order to be accepted into the system, as well as defaults for their related fields.",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0019",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0019.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0019",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf /n on the master node and set the --enable-admission-plugins parameter to a /n value that does not include AlwaysAdmit. References: https://kubernetes.io/docs/admin/kube-apiserver/  https://kubernetes.io/docs/admin/admission-controllers/#alwaysadmit",
                            "remediationFunction": "PR-K8S-0019.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the admission control plugin AlwaysAdmit is not set (API Server) ",
                    "description": " Do not allow all requests. Setting admission control plugin AlwaysAdmit allows all requests and do not filter any requests. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0020",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0020.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0020",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Follow the documentation and configure alternate mechanisms for authentication. Then, /n edit the API server pod specification file $apiserverconf /n on the master node and remove the --basic-auth-file= /n parameter. References: https://kubernetes.io/docs/admin/kube-apiserver/ https://kubernetes.io/docs/admin/authentication/#static-password-file ",
                            "remediationFunction": "PR-K8S-0020.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --basic-auth-file argument is not set (API Server) ",
                    "description": " Do not use basic authentication. Basic authentication uses plaintext credentials for authentication. Currently, the basic authentication credentials last indefinitely, and the password cannot be changed without restarting API server. The basic authentication is currently supported for convenience. Hence, basic authentication should not be used. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0021",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0021.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0021",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Seccomp is an alpha feature currently. By default, all alpha features are disabled. So, you would need to enable alpha features in the apiserver by passing \"--feature-gates=AllAlpha=true\" argument. Edit the /etc/kubernetes/apiserver file on the master node and set the KUBE_API_ARGS parameter to \"--feature-gates=AllAlpha=true\" KUBE_API_ARGS=\"--feature-gates=AllAlpha=true\" Based on your system, restart the kube-apiserver service. For example: systemctl restart kube-apiserver.service References: https://github.com/kubernetes/kubernetes/issues/39845 https://github.com/kubernetes/kubernetes/pull/21790 https://github.com/kubernetes/community/blob/master/contributors/design-proposals/seccomp.md#examples https://docs.docker.com/engine/security/seccomp/",
                            "remediationFunction": "PR-K8S-0021.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": "Ensure that the seccomp profile is set to runtime/default in your pod definitions",
                    "description": "Enable runtime/default seccomp profile in your pod definitions. Seccomp (secure computing mode) is used to restrict the set of system calls applications can make, allowing cluster administrators greater control over the security of workloads running in the cluster. Kubernetes disables seccomp profiles by default for historical reasons. You should enable it to ensure that the workloads have restricted actions available within the container.",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0022",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0022.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0022",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf on the master node and set the below parameter.--profiling=false References: https://kubernetes.io/docs/admin/kube-apiserver/ https://github.com/kubernetes/community/blob/master/contributors/devel/profiling.md",
                            "remediationFunction": "PR-K8S-0022.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --profiling argument is set to false (API Server) ",
                    "description": " Disable profiling, if not needed. Profiling allows for the identification of specific performance bottlenecks. It generates a significant amount of program data that could potentially be exploited to uncover system and program details. If you are not experiencing any bottlenecks and do not need the profiler for troubleshooting purposes, it is recommended to turn it off to reduce the potential attack surface.",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0023",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0023.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0023",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "To enable containers with AppArmor, please refer to the documentation - https://kubernetes.io/docs/tutorials/clusters/apparmor/#securing-a-pod",
                            "remediationFunction": "PR-K8S-0023.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": "Ensure containers are secured with AppArmor profile",
                    "description": " Containers with no AppArmor profile - AppArmor is a Linux kernel security module that supplements the standard Linux user and group based permissions to confine programs to a limited set of resources. AppArmor can be configured for any application to reduce its potential attack surface and provide greater in-depth defense. It is configured through profiles tuned to whitelist the access needed by a specific program or container, such as Linux capabilities, network access, file permissions, etc. Each profile can be run in either enforcing mode, which blocks access to disallowed resources, or complain mode, which only reports violations. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0024",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0024.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0024",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Follow the Kubernetes documentation and setup the TLS connection between the /n apiserver and kubelets. Then, edit the API server pod specification file /n $apiserverconf on the master node and set the --kubelet-certificate-authority parameter to the path to the cert file for the certificate authority. --kubelet-certificate-authority= References: https://kubernetes.io/docs/admin/kube-apiserver/ https://kubernetes.io/docs/admin/kubelet-authentication-authorization/ https://kubernetes.io/docs/concepts/cluster-administration/master-node-communication/#apiserver---kubelet ",
                            "remediationFunction": "PR-K8S-0024.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --kubelet-certificate-authority argument is set as appropriate (API Server) ",
                    "description": " Verify kubelet's certificate before establishing connection. The connections from the apiserver to the kubelet are used for fetching logs for pods, attaching (through kubectl) to running pods, and using the kubelet’s port-forwarding functionality. These connections terminate at the kubelet’s HTTPS endpoint. By default, the apiserver does not verify the kubelet’s serving certificate, which makes the connection subject to man-in-the-middle attacks, and unsafe to run over untrusted and/or public networks. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0025",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0025.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0025",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Follow the Kubernetes documentation and set up the TLS connection between the apiserver and kubelets. Then, edit API server pod specification file /n $apiserverconf on the master node and set the /n kubelet client certificate and key parameters as below. /n --kubelet-client-certificate= /n --kubelet-client-key= /n References: https://kubernetes.io/docs/admin/kube-apiserver/ https://kubernetes.io/docs/admin/kubelet-authentication-authorization/ https://kubernetes.io/docs/concepts/cluster-administration/master-node-communication/#apiserver---kubelet ",
                            "remediationFunction": "PR-K8S-0025.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --kubelet-client-certificate and --kubelet-client-key arguments are set as appropriate (API Server) ",
                    "description": " Enable certificate based kubelet authentication. The apiserver, by default, does not authenticate itself to the kubelet's HTTPS endpoints. The requests from the apiserver are treated anonymously. You should set up certificate-based kubelet authentication to ensure that the apiserver authenticates itself to kubelets when submitting requests.",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0026",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0026.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0026",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Follow the documentation and create Pod Security Policy objects as per your environment. Then, edit the API server pod specification file $apiserverconf /n on the master node and set the --enable-admission-plugins parameter to a /n value that includes PodSecurityPolicy : /n --enable-admission-plugins=...,PodSecurityPolicy,... /n Then restart the API Server. References: https://kubernetes.io/docs/admin/kube-apiserver/ https://kubernetes.io/docs/admin/admission-controllers/#podsecuritypolicy https://kubernetes.io/docs/concepts/policy/pod-security-policy/#enabling-pod-security-policies",
                            "remediationFunction": "PR-K8S-0026.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": "Ensure that the admission control plugin PodSecurityPolicy is set (API Server)",
                    "description": " Reject creating pods that do not match Pod Security Policies. A Pod Security Policy is a cluster-level resource that controls the actions that a pod can perform and what it has the ability to access. The PodSecurityPolicy objects define a set of conditions that a pod must run with in order to be accepted into the system. Pod Security Policies are comprised of settings and strategies that control the security features a pod has access to and hence this must be used to control pod access permissions.",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0027",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0027.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0027",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverbin on the master node and set the --authorization-mode parameter to a value that includes RBAC, for example: --authorization-mode=Node,RBAC /n References: https://kubernetes.io/docs/reference/access-authn-authz/rbac/",
                            "remediationFunction": "PR-K8S-0027.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --authorization-mode argument includes RBAC (API Server) ",
                    "description": " Turn on Role Based Access Control. Role Based Access Control (RBAC) allows fine-grained control over the operations that different entities can perform on different objects in the cluster. It is recommended to use the RBAC authorisation mode. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0028",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0028.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0028",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file /etc/kubernetes/manifests/kube-apiserver.yaml on the master node and set the below parameter. --anonymous-auth=false /n References: https://kubernetes.io/docs/admin/kube-apiserver/ https://kubernetes.io/docs/admin/authentication/#anonymous-requests",
                            "remediationFunction": "PR-K8S-0028.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --anonymous-auth argument is set to false (API Server) ",
                    "description": " Disable anonymous requests to the API server.When enabled, requests that are not rejected by other configured authentication methods are treated as anonymous requests. These requests are then served by the API server. You should rely on authentication to authorize access and disallow anonymous requests. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0029",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0029.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0029",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the Scheduler pod specification file $schedulerconf /n file on the master node and set the below parameter. --profiling=false /n References: https://kubernetes.io/docs/admin/kube-scheduler/ https://github.com/kubernetes/community/blob/master/contributors/devel/profiling.md",
                            "remediationFunction": "PR-K8S-0029.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --profiling argument is set to false (Scheduler) ",
                    "description": " Disable profiling, if not needed. Profiling allows for the identification of specific performance bottlenecks. It generates a significant amount of program data that could potentially be exploited to uncover system and program details. If you are not experiencing any bottlenecks and do not need the profiler for troubleshooting purposes, it is recommended to turn it off to reduce the potential attack surface. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0030",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0030.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0030",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": " Ensure that namespaces are created to allow for appropriate segregation of Kubernetes resources and that all new resources are created in a specific namespace. ",
                            "remediationFunction": "PR-K8S-0030.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " The default namespace should not be used ",
                    "description": " Kubernetes provides a default namespace, where objects are placed if no namespace is specified for them. Placing objects in this namespace makes application of RBAC and other controls more difficult. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0031",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0031.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0031",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the Controller Manager pod specification file $controllermanagerconf /n on the master node and set the --terminated-pod-gc-threshold to an appropriate threshold, for example: /n --terminated-pod-gc-threshold=10 /n References: https://kubernetes.io/docs/admin/kube-controller-manager/ https://github.com/kubernetes/kubernetes/issues/28484",
                            "remediationFunction": "PR-K8S-0031.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --terminated-pod-gc-threshold argument is set as appropriate (Controller Manager) ",
                    "description": " Activate garbage collector on pod termination, as appropriate. Garbage collection is important to ensure sufficient resource availability and avoiding degraded performance and availability. In the worst case, the system might crash or just be unusable for a long period of time. The current setting for garbage collection is 12,500 terminated pods which might be too high for your system to sustain. Based on your system resources and tests, choose an appropriate threshold value to activate garbage collection. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0032",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0032.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0032",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the Controller Manager pod specification file $controllermanagerconf /n on the master node and set the below parameter. /n --profiling=false /n References: https://kubernetes.io/docs/admin/kube-controller-manager/ https://github.com/kubernetes/community/blob/master/contributors/devel/profiling.md",
                            "remediationFunction": "PR-K8S-0032.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --profiling argument is set to false (Controller Manager) ",
                    "description": " Disable profiling, if not needed. Profiling allows for the identification of specific performance bottlenecks. It generates a significant amount of program data that could potentially be exploited to uncover system and program details. If you are not experiencing any bottlenecks and do not need the profiler for troubleshooting purposes, it is recommended to turn it off to reduce the potential attack surface. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0033",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0033.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0033",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the Controller Manager pod specification file $controllermanagerconf /n on the master node to set the below parameter. /n --use-service-account-credentials=true /n References: https://kubernetes.io/docs/admin/kube-controller-manager/ https://kubernetes.io/docs/admin/service-accounts-admin/ https://github.com/kubernetes/kubernetes/blob/release-1.6/plugin/pkg/auth/authorizer/rbac/bootstrappolicy/testdata/controller-roles.yaml https://github.com/kubernetes/kubernetes/blob/release-1.6/plugin/pkg/auth/authorizer/rbac/bootstrappolicy/testdata/controller-role-bindings.yaml https://kubernetes.io/docs/admin/authorization/rbac/#controller-roles",
                            "remediationFunction": "PR-K8S-0033.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --use-service-account-credentials argument is set to true (Controller Manager) ",
                    "description": " Use individual service account credentials for each controller. The controller manager creates a service account per controller in the kube-system namespace, generates a credential for it, and builds a dedicated API client with that service account credential for each controller loop to use. Setting the --use-service-account-credentials to true runs each control loop within the controller manager using a separate service account credential. When used in combination with RBAC, this ensures that the control loops run with the minimum permissions required to perform their intended tasks. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0034",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0034.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0034",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the Controller Manager pod specification file $controllermanagerconf /n on the master node and set the --root-ca-file parameter to /n the certificate bundle file. /n --root-ca-file= /n References: https://kubernetes.io/docs/admin/kube-controller-manager/ https://github.com/kubernetes/kubernetes/issues/11000 ",
                            "remediationFunction": "PR-K8S-0034.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --root-ca-file argument is set as appropriate (Controller Manager) ",
                    "description": " Allow pods to verify the API server's serving certificate before establishing connections. Processes running within pods that need to contact the API server must verify the API server's serving certificate. Failing to do so could be a subject to man-in-the-middle attacks. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0035",
                    "masterSnapshotId": [
                        "K8SSNP_SERVICEACC_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0035.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0035",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": " Modify the definition of pods and service accounts which do not need to mount service account tokens to disable it. ",
                            "remediationFunction": "PR-K8S-0035.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that Service Account Tokens are only mounted where necessary (RBAC) ",
                    "description": " Service accounts tokens should not be mounted in pods except where the workload running in the pod explicitly needs to communicate with the API server. Mounting service account tokens inside pods can provide an avenue for privilege escalation attacks where an attacker is able to compromise a single pod in the cluster. Avoiding mounting these tokens removes this attack avenue. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "serviceaccount"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0036",
                    "masterSnapshotId": [
                        "K8SSNP_NETWORKPOLICY_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0036.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0036",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Pods in a cluster can communicate with each other and should be controlled using Network Policies as needed for your workload. Network policies are implemented by the network plugin, so you must be using a networking solution which supports NetworkPolicy - simply creating the resource without a controller to implement it will have no effect. Kubernetes' Network Policies make it much more difficult for attackers to move laterally within your cluster. You can also use the Kubernetes Network Policy API to create Pod-level firewall rules. These firewall rules determine which Pods and services can access one another inside your cluster. You can find an example of NetworkPolicy : https://kubernetes.io/docs/concepts/services-networking/network-policies/#the-networkpolicy-resource /nFor more information on NetworkPolicy, please refer : https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#networkpolicy-v1-networking-k8s-io",
                            "remediationFunction": "PR-K8S-0036.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Restrict Traffic Among Pods with a Network Policy",
                    "description": " Network policies are Kubernetes resources that control the traffic between pods and/or network endpoints. They uses labels to select pods and specify the traffic that is directed toward those pods using rules. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "networkpolicy"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0041",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0041.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0041",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Follow the Kubernetes documentation and set the desired limits in a configuration file. Then, edit the API server pod specification file /n $apiserverconf and set the below parameters. /n --enable-admission-plugins=...,EventRateLimit,... /n --admission-control-config-file= /n References: https://kubernetes.io/docs/admin/kube-apiserver/ https://kubernetes.io/docs/admin/admission-controllers/#eventratelimit https://github.com/staebler/community/blob/9873b632f4d99b5d99c38c9b15fe2f8b93d0a746/contributors/design-proposals/admission_control_event_rate_limit.md ",
                            "remediationFunction": "PR-K8S-0041.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the admission control plugin EventRateLimit is set (API Server) ",
                    "description": " Limit the rate at which the API server accepts requests. Using EventRateLimit admission control enforces a limit on the number of events that the API Server will accept in a given time slice. In a large multi-tenant cluster, there might be a small percentage of misbehaving tenants which could have a significant impact on the performance of the cluster overall. Hence, it is recommended to limit the rate of events that the API server will accept. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0042",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0042.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0042",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf /n on the master node and remove the --insecure-bind-address /n parameter. References: https://kubernetes.io/docs/admin/kube-apiserver/",
                            "remediationFunction": "PR-K8S-0042.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --insecure-bind-address argument is not set (API Server) ",
                    "description": " Do not bind the insecure API service. If you bind the apiserver to an insecure address, basically anyone who could connect to it over the insecure port, would have unauthenticated and unencrypted access to your master node. The apiserver doesn't do any authentication checking for insecure binds and traffic to the Insecure API port is not encrpyted, allowing attackers to potentially read sensitive data in transit. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0043",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0043.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0043",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf on the master node and either remove the --secure-port parameter or set it to a different (non-zero) desired port. References: https://kubernetes.io/docs/admin/kube-apiserver/",
                            "remediationFunction": "PR-K8S-0043.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --secure-port argument is not set to 0 (API Server) ",
                    "description": " Do not disable the secure port. The secure port is used to serve https with authentication and authorization. If you disable it, no https traffic is served and all traffic is served unencrypted. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0044",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0044.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0044",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf /n on the master node and set the below parameter. --repair-malformed-updates=false ",
                            "remediationFunction": "PR-K8S-0044.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --repair-malformed-updates argument is set to false (API Server) ",
                    "description": " Disable fixing of malformed updates. The API Server will potentially attempt to fix the update requests to pass the validation even if the requests are malformed. Malformed requests are one of the potential ways to interact with a service without legitimate information. Such requests could potentially be used to sabotage API Server responses. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0045",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0045.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0045",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf on the master node and set the --enable-admission-plugins to /n include AlwaysPullImages. /n --enable-admission-plugins=...,AlwaysPullImages,... /n References: https://kubernetes.io/docs/admin/kube-apiserver/ https://kubernetes.io/docs/admin/admission-controllers/#alwayspullimages",
                            "remediationFunction": "PR-K8S-0045.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the admission control plugin AlwaysPullImages is set (API Server) ",
                    "description": " Always pull images. Setting admission control policy to AlwaysPullImages forces every new pod to pull the required images every time. In a multi-tenant cluster users can be assured that their private images can only be used by those who have the credentials to pull them. Without this admission control policy, once an image has been pulled to a node, any pod from any user can use it simply by knowing the image’s name, without any authorization check against the image ownership. When this plug-in is enabled, images are always pulled prior to starting containers, which means valid credentials are required. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0046",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0046.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0046",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf /n on the master node and set the --disable-admission-plugins parameter to /n ensure it does not include NamespaceLifecycle. /n --disable-admission-plugins=...,NamespaceLifecycle,... /n References: https://kubernetes.io/docs/admin/kube-apiserver/ https://kubernetes.io/docs/admin/admission-controllers/#namespacelifecycle",
                            "remediationFunction": "PR-K8S-0046.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the admission control plugin NamespaceLifecycle is set (API Server) ",
                    "description": " Reject creating objects in a namespace that is undergoing termination. Setting admission control policy to NamespaceLifecycle ensures that objects cannot be created in non-existent namespaces, and that namespaces undergoing termination are not used for creating the new objects. This is recommended to enforce the integrity of the namespace termination process and also for the availability of the newer objects. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0047",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0047.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0047",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf /n on the master node and remove the --insecure-allow-any-token /n parameter. ",
                            "remediationFunction": "PR-K8S-0047.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --insecure-allow-any-token argument is not set (API Server) ",
                    "description": " Ensure that the API server is configured to only use strong cryptographic ciphers. TLS ciphers have had a number of known vulnerabilities and weaknesses, which can reduce the protection provided by them. By default Kubernetes supports a number of TLS ciphersuites including some that have security concerns, weakening the protection provided. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0048",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0048.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0048",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf on the master node and set the --authorization-mode parameter to a value that includes Node. /n --authorization-mode=Node,RBAC ",
                            "remediationFunction": "PR-K8S-0048.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --authorization-mode argument is set to Node (API Server) ",
                    "description": " Restrict kubelet nodes to reading only objects associated with them. The Node authorization mode only allows kubelets to read Secret, ConfigMap, PersistentVolume, and PersistentVolumeClaim objects associated with their nodes. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0049",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0049.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0049",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Follow the Kubernetes documentation and configure NodeRestriction plug-in on kubelets. Then, edit the API server pod specification file $apiserverconf on the master node and set the --enable-admission-plugins parameter to a value that includes NodeRestriction. /n --enable-admission-plugins=...,NodeRestriction,... /n References: https://kubernetes.io/docs/admin/kube-apiserver/ https://kubernetes.io/docs/admin/admission-controllers/#noderestriction https://kubernetes.io/docs/admin/authorization/node/ https://acotten.com/post/kube17-security",
                            "remediationFunction": "PR-K8S-0049.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the admission control plugin NodeRestriction is set (API Server) ",
                    "description": " Limit the Node and Pod objects that a kubelet could modify. Using the NodeRestriction plug-in ensures that the kubelet is restricted to the Node and Pod objects that it could modify as defined. Such kubelets will only be allowed to modify their own Node API object, and only modify Pod API objects that are bound to their node ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0050",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0050.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0050",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf apiserver.yaml on the master node and set the below parameter. --insecure-port=0 /n References: https://kubernetes.io/docs/admin/kube-apiserver/",
                            "remediationFunction": "PR-K8S-0050.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --insecure-port argument is set to 0 (API Server) ",
                    "description": " Do not bind to insecure port. Setting up the apiserver to serve on an insecure port would allow unauthenticated and unencrypted access to your master node. This would allow attackers who could access this port, to easily take control of the cluster. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0052",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0052.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0052",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the Scheduler pod specification file $schedulerconf file on the master node and ensure the correct value for the --address parameter. ",
                            "remediationFunction": "PR-K8S-0052.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --address argument is set to 127.0.0.1 (Scheduler) ",
                    "description": " Do not bind the scheduler service to non-loopback insecure addresses. The Scheduler API service which runs on port 10251/TCP by default is used for health and metrics information and is available without authentication or encryption. As such it should only be bound to a localhost interface, to minimize the cluster's attack surface ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0053",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0053.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0053",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the Controller Manager pod specification file $controllermanagerconf controller-manager.yaml on the master node and ensure the correct value for the --address parameter. ",
                            "remediationFunction": "PR-K8S-0053.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --address argument is set to 127.0.0.1 (Controller Manager) ",
                    "description": " Do not bind the Controller Manager service to non-loopback insecure addresses. The Controller Manager API service which runs on port 10252/TCP by default is used for health and metrics information and is available without authentication or encryption. As such it should only be bound to a localhost interface, to minimize the cluster's attack surface ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0054",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0054.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0054",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf on the master node and set the --enable-admission-plugins parameter to a value that includes DenyEscalatingExec. --enable-admission-plugins=...,DenyEscalatingExec,... ",
                            "remediationFunction": "PR-K8S-0054.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the admission control plugin DenyEscalatingExec is set (API Server) ",
                    "description": " Deny execution of exec and attach commands in privileged pods. Setting admission control policy to DenyEscalatingExec denies exec and attach commands to pods that run with escalated privileges that allow host access. This includes pods that run as privileged, have access to the host IPC namespace, and have access to the host PID namespace. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0055",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0055.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0055",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the Controller Manager pod specification file /etc/kubernetes/manifests/kube-controller-manager.yaml on the master node and ensure the correct value for the --bind-address parameter References: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/",
                            "remediationFunction": "PR-K8S-0055.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --bind-address argument is set to 127.0.0.1 (Controller Manager) ",
                    "description": " Do not bind the Controller Manager service to non-loopback insecure addresses. The Controller Manager API service which runs on port 10252/TCP by default is used for health and metrics information and is available without authentication or encryption. As such it should only be bound to a localhost interface, to minimize the cluster's attack surface ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0056",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0056.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0056",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the Scheduler pod specification file /etc/kubernetes/manifests/kube-scheduler.yaml on the master node and ensure the correct value for the --bind-address parameter References: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/",
                            "remediationFunction": "PR-K8S-0056.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --bind-address argument is set to 127.0.0.1 (Scheduler) ",
                    "description": " Do not bind the scheduler service to non-loopback insecure addresses. The Scheduler API service which runs on port 10251/TCP by default is used for health and metrics information and is available without authentication or encryption. As such it should only be bound to a localhost interface, to minimize the cluster's attack surface ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0057",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0057.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0057",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Please refer to the Kubernetes documentation on how to configure the hostpath: https://kubernetes.io/docs/concepts/storage/volumes/#hostpath",
                            "remediationFunction": "PR-K8S-0057.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure pods outside of kube-system do not have access to node volume ",
                    "description": " A hostPath volume mounts a file or directory from the host node’s filesystem into your Pod. This is not something that most Pods will need, but it offers a powerful escape hatch for some applications. It is important to watch out when using this type of volume because; when Kubernetes adds resource-aware scheduling, as is planned, it will not be able to account for resource used by a hostPath. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0058",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0058.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0058",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf on the master node and set the --authorization-mode parameter to values other than AlwaysAllow. One such example could be as below. --authorization-mode=RBAC References: https://kubernetes.io/docs/admin/kube-apiserver/ https://kubernetes.io/docs/admin/authorization/",
                            "remediationFunction": "PR-K8S-0058.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --authorization-mode argument is not set to AlwaysAllow (API Server) ",
                    "description": " Do not always authorize all requests. The API Server, can be configured to allow all requests. This mode should not be used on any production cluster. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0059",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0059.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0059",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf on the master node and set the --audit-log-path parameter to a suitable path and file where you would like audit logs to be written, for example: --audit-log-path=/var/log/apiserver/audit.log ",
                            "remediationFunction": "PR-K8S-0059.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --audit-log-path argument is set as appropriate (API Server) ",
                    "description": " Enable auditing on the Kubernetes API Server and set the desired audit log path as appropriate. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0060",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0060.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0060",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf on the master node and set the --audit-log-maxage parameter to 30 or as an appropriate number of days: --audit-log-maxage=30 References: https://kubernetes.io/docs/admin/kube-apiserver/ https://kubernetes.io/docs/concepts/cluster-administration/audit/ https://github.com/kubernetes/features/issues/22",
                            "remediationFunction": "PR-K8S-0060.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --audit-log-maxage argument is set to 30 or as appropriate (API Server) ",
                    "description": " Retain the logs for at least 30 days or as appropriate. Retaining logs for at least 30 days ensures that you can go back in time and investigate or correlate any events. Set your audit log retention period to 30 days or as per your business requirements. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0061",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0061.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0061",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf on the master node and set the --audit-log-maxbackup parameter to 10 or to an appropriate value. --audit-log-maxbackup=10 References: https://kubernetes.io/docs/admin/kube-apiserver/ https://kubernetes.io/docs/concepts/cluster-administration/audit/ https://github.com/kubernetes/features/issues/22",
                            "remediationFunction": "PR-K8S-0061.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --audit-log-maxbackup argument is set to 10 or as appropriate (API Server) ",
                    "description": " Retain 10 or an appropriate number of old log files. Kubernetes automatically rotates the log files. Retaining old log files ensures that you would have sufficient log data available for carrying out any investigation or correlation. For example, if you have set file size of 100 MB and the number of old log files to keep as 10, you would approximate have 1 GB of log data that you could potentially use for your analysis. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0062",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0062.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0062",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf on the master node and set the --audit-log-maxsize parameter to an appropriate size in MB. For example, to set it as 100 MB: --audit-log-maxsize=100 References: https://kubernetes.io/docs/admin/kube-apiserver/ https://kubernetes.io/docs/concepts/cluster-administration/audit/ https://github.com/kubernetes/features/issues/22",
                            "remediationFunction": "PR-K8S-0062.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --audit-log-maxsize argument is set to 100 or as appropriate (API Server) ",
                    "description": " Rotate log files on reaching 100 MB or as appropriate. Kubernetes automatically rotates the log files. Retaining old log files ensures that you would have sufficient log data available for carrying out any investigation or correlation. If you have set file size of 100 MB and the number of old log files to keep as 10, you would approximate have 1 GB of log data that you could potentially use for your analysis. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0063",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0063.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0063",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Follow the Kubernetes documentation and set the desired audit policy in the /etc/kubernetes/audit-policy.yaml file. Then, edit the API server pod specification file $apiserverconf and set the below parameters. --audit-policy-file=/etc/kubernetes/audit-policy.yaml ",
                            "remediationFunction": "PR-K8S-0063.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the AdvancedAuditing argument is not set to false (API Server) ",
                    "description": " Do not disable advanced auditing. AdvancedAuditing enables a much more general API auditing pipeline, which includes support for pluggable output backends and an audit policy specifying how different requests should be audited. Additionally, this enables auditing of failed authentication, authorization and login attempts which could prove crucial for protecting your production clusters. It is thus recommended not to disable advanced auditing. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0067",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0067.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0067",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the Controller Manager pod specification file $controllermanagerconf controller-manager.yaml on the master node and set the --feature-gates parameter to include RotateKubeletServerCertificate=true. --feature-gates=RotateKubeletServerCertificate=true References: https://kubernetes.io/docs/admin/kubelet-tls-bootstrapping/#approval-controller https://github.com/kubernetes/features/issues/267 https://github.com/kubernetes/kubernetes/pull/45059 https://kubernetes.io/docs/admin/kube-controller-manager/",
                            "remediationFunction": "PR-K8S-0067.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the RotateKubeletServerCertificate argument is set to true (Controller Manager) ",
                    "description": " Enable kubelet server certificate rotation on controller-manager. RotateKubeletServerCertificate causes the kubelet to both request a serving certificate after bootstrapping its client credentials and rotate the certificate as its existing credentials expire. This automated periodic rotation ensures that the there are no downtimes due to expired certificates and thus addressing availability in the CIA security triad. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0068",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0068.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0068",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Follow the Kubernetes documentation and set up the TLS connection between the apiserver and etcd. Then, edit the API server pod specification file $apiserverconf on the master node and set the etcd certificate authority file parameter. --etcd-cafile= /n References: https://kubernetes.io/docs/admin/kube-apiserver/ https://coreos.com/etcd/docs/latest/op-guide/security.html ",
                            "remediationFunction": "PR-K8S-0068.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --etcd-cafile argument is set as appropriate (API Server) ",
                    "description": " etcd should be configured to make use of TLS encryption for client connections. etcd is a highly-available key value store used by Kubernetes deployments for persistent storage of all of its REST API objects. These objects are sensitive in nature and should be protected by client authentication. This requires the API server to identify itself to the etcd server using a SSL Certificate Authority file. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0069",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0069.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0069",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf on the master node and remove the --kubelet-https parameter. References: https://kubernetes.io/docs/admin/kube-apiserver/ https://kubernetes.io/docs/admin/kubelet-authentication-authorization/",
                            "remediationFunction": "PR-K8S-0069.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --kubelet-https argument is set to true (API Server) ",
                    "description": " Use https for kubelet connections. Connections from apiserver to kubelets could potentially carry sensitive data such as secrets and keys. It is thus important to use in-transit encryption for any communication between the apiserver and kubelets. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0070",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0070.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0070",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the Controller Manager pod specification file $controllermanagerconf on the master node and set the --service-account-private- key-file parameter to the private key file for service accounts. --service-account-private-key-file= References: https://kubernetes.io/docs/admin/kube-controller-manager/ ",
                            "remediationFunction": "PR-K8S-0070.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --service-account-private-key-file argument is set as appropriate (Controller Manager) ",
                    "description": " Explicitly set a service account private key file for service accounts on the controller manager. To ensure that keys for service account tokens can be rotated as needed, a separate public/private key pair should be used for signing service account tokens. The private key should be specified to the controller manager with --service-account-private-key-file as appropriate. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0071",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0071.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0071",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Follow the Kubernetes documentation and set up the TLS connection between the apiserver and etcd. Then, edit the API server pod specification file $apiserverconf on the master node and set the etcd certificate and key file parameters. /n --etcd-certfile= /n --etcd-keyfile= /n References: https://kubernetes.io/docs/admin/kube-apiserver/ https://coreos.com/etcd/docs/latest/op-guide/security.html ",
                            "remediationFunction": "PR-K8S-0071.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --etcd-certfile and --etcd-keyfile arguments are set as appropriate (API Server) ",
                    "description": " etcd should be configured to make use of TLS encryption for client connections. etcd is a highly-available key value store used by Kubernetes deployments for persistent storage of all of its REST API objects. These objects are sensitive in nature and should be protected by client authentication. This requires the API server to identify itself to the etcd server using a client certificate and key. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0072",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0072.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0072",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the etcd pod specification file $etcdconf on the master node and set the below parameter. --client-cert-auth=\"true\" /n References: https://coreos.com/etcd/docs/latest/op-guide/security.html https://kubernetes.io/docs/admin/etcd/ https://coreos.com/etcd/docs/latest/op-guide/configuration.html#client-cert-auth",
                            "remediationFunction": "PR-K8S-0072.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --client-cert-auth argument is set to true (etcd) ",
                    "description": " Enable client authentication on etcd service. etcd is a highly-available key value store used by Kubernetes deployments for persistent storage of all of its REST API objects. These objects are sensitive in nature and should not be available to unauthenticated clients. You should enable the client authentication via valid certificates to secure the access to the etcd service. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0073",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0073.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0073",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the etcd pod specification file $etcdconf on the master node and either remove the --auto-tls parameter or set it to false. --auto-tls=false /n References: https://coreos.com/etcd/docs/latest/op-guide/security.html https://kubernetes.io/docs/admin/etcd/ https://coreos.com/etcd/docs/latest/op-guide/configuration.html#auto-tls",
                            "remediationFunction": "PR-K8S-0073.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --auto-tls argument is not set to true (etcd) ",
                    "description": " Do not use self-signed certificates for TLS. etcd is a highly-available key value store used by Kubernetes deployments for persistent storage of all of its REST API objects. These objects are sensitive in nature and should not be available to unauthenticated clients. You should enable the client authentication via valid certificates to secure the access to the etcd service. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0074",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0074.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0074",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Follow the documentation and configure alternate mechanisms for authentication. Then, edit the API server pod specification file $apiserverconf on the master node and remove the --token-auth-file= parameter. ",
                            "remediationFunction": "PR-K8S-0074.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --token-auth-file parameter is not set (API Server) ",
                    "description": " Do not use token based authentication. The token-based authentication utilizes static tokens to authenticate requests to the apiserver. The tokens are stored in clear-text in a file on the apiserver, and cannot be revoked or rotated without restarting the apiserver. Hence, do not use static token-based authentication. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0075",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0075.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0075",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Follow the Kubernetes documentation and set up the TLS connection on the apiserver. Then, edit the API server pod specification file $apiserverconf on the master node and set the TLS certificate and private key file parameters. /n --tls-cert-file= /n --tls-private-key-file= /n References: https://kubernetes.io/docs/admin/kube-apiserver/ http://rootsquash.com/2016/05/10/securing-the-kubernetes-api/ https://github.com/kelseyhightower/docker-kubernetes-tls-guide ",
                            "remediationFunction": "PR-K8S-0075.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --tls-cert-file and --tls-private-key-file arguments are set as appropriate (API Server) ",
                    "description": " Setup TLS connection on the API server. API server communication contains sensitive parameters that should remain encrypted in transit. Configure the API server to serve only HTTPS traffic. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0076",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0076.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0076",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Follow the Kubernetes documentation and set up the TLS connection on the apiserver. Then, edit the API server pod specification file $apiserverconf on the master node and set the client certificate authority file. /n --client-ca-file= /n References: https://kubernetes.io/docs/admin/kube-apiserver/ http://rootsquash.com/2016/05/10/securing-the-kubernetes-api/ https://github.com/kelseyhightower/docker-kubernetes-tls-guide ",
                            "remediationFunction": "PR-K8S-0076.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --client-ca-file argument is set as appropriate (API Server) ",
                    "description": " Setup TLS connection on the API server. API server communication contains sensitive parameters that should remain encrypted in transit. Configure the API server to serve only HTTPS traffic. If --client-ca-file argument is set, any request presenting a client certificate signed by one of the authorities in the client-ca-file is authenticated with an identity corresponding to the CommonName of the client certificate. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0078",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0078.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0078",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf on the master node and set the below parameter. --service-account-lookup=true /n References: https://kubernetes.io/docs/admin/kube-apiserver/ https://github.com/kubernetes/kubernetes/issues/24167 https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use",
                            "remediationFunction": "PR-K8S-0078.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --service-account-lookup argument is set to true (API Server) ",
                    "description": " Validate service account before validating token. If --service-account-lookup is not enabled, the apiserver only verifies that the authentication token is valid, and does not validate that the service account token mentioned in the request is actually present in etcd. This allows using a service account token even after the corresponding service account is deleted. This is an example of time of check to time of use security issue. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0079",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0079.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0079",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Follow the documentation and create ServiceAccount objects as per your environment. Then, edit the API server pod specification file $apiserverconf on the master node and set the --enable-admission-plugins parameter to a value that includes ServiceAccount. /n --enable-admission-plugins=...,ServiceAccount,... /n References: https://kubernetes.io/docs/admin/kube-apiserver/ https://kubernetes.io/docs/admin/admission-controllers/#serviceaccount https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
                            "remediationFunction": "PR-K8S-0079.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the admission control plugin ServiceAccount is set (API Server) ",
                    "description": " Automate service accounts management. When you create a pod, if you do not specify a service account, it is automatically assigned the default service account in the same namespace. You should create your own service account and let the API server manage its security tokens. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0083",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0083.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0083",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Edit the API server pod specification file $apiserverconf on the master node and set the --service-account-key-file parameter to the public key file for service accounts: --service-account-key-file= /n References: https://kubernetes.io/docs/admin/kube-apiserver/ https://github.com/kubernetes/kubernetes/issues/24167 ",
                            "remediationFunction": "PR-K8S-0083.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Ensure that the --service-account-key-file argument is set as appropriate (API Server) ",
                    "description": " Explicitly set a service account public key file for service accounts on the apiserver. By default, if no --service-account-key-file is specified to the apiserver, it uses the private key from the TLS serving certificate to verify service account tokens. To ensure that the keys for service account tokens could be rotated as needed, a separate public/private key pair should be used for signing service account tokens. Hence, the public key should be specified to the apiserver with --service-account-key-file. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                },
                {
                    "masterTestId": "K8S_test_0084",
                    "masterSnapshotId": [
                        "K8SSNP_POD_"
                    ],
                    "type": "rego",
                    "rule": "file(PR-K8S-0084.rego)",
                    "evals": [
                        {
                            "id": "PR-K8S-0084",
                            "eval": "data.rule.rulepass",
                            "message": "data.rule.rulepass_err",
                            "remediationDescription": "Follow the Kubernetes documentation and apply security contexts to your pods. For a suggested list of security contexts, you may refer to the CIS Security Benchmark for Docker Containers. Please refer : https://kubernetes.io/docs/concepts/policy/security-context/",
                            "remediationFunction": "PR-K8S-0084.py",
                            "severity": "Medium"
                        }
                    ],
                    "title": " Apply Security Context to Your Pods and Containers ",
                    "description": " Apply Security Context to Your Pods and Containers. A security context defines the operating system security settings (uid, gid, capabilities, SELinux role, etc..) applied to a container. When designing your containers and pods, make sure that you configure the security context for your pods, containers, and volumes. A security context is a property defined in the deployment yaml. It controls the security parameters that will be assigned to the pod/container/volume. ",
                    "tags": [
                        {
                            "cloud": "kubernetes",
                            "compliance": [
                                "CIS"
                            ],
                            "service": [
                                "pod"
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}